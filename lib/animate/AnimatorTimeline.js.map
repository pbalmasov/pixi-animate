{"version":3,"sources":["../../src/animate/AnimatorTimeline.js"],"names":["pool","AnimatorTimeline","_update","update","bind","init","instance","start","end","loop","callback","gotoAndStop","_beforeUpdate","destroy","_pool","push","completed","currentFrame","_updateTimeline","gotoAndPlay","stop","PIXI","animate","Animator","_internalStop","create","timeline","length","pop","progress","Math","max","min","module","exports"],"mappings":";;;;;;AAAA,IAAMA,OAAO,EAAb;;AAEA;;;;;;IAKMC,gB;AACF,gCAAc;AAAA;;AACV,aAAKC,OAAL,GAAe,KAAKC,MAAL,CAAYC,IAAZ,CAAiB,IAAjB,CAAf;AACA,aAAKC,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACH;;AAED;;;;;;;;;;;;+BAUAA,I,iBAAKC,Q,EAAUC,K,EAAOC,G,EAAKC,I,EAAMC,Q,EAAU;;AAEvC;;;;;;AAMA,aAAKJ,QAAL,GAAgBA,QAAhB;;AAEA;;;;;;AAMA,aAAKG,IAAL,GAAYA,IAAZ;;AAEA;;;;;;AAMA,aAAKF,KAAL,GAAaA,KAAb;;AAEA;;;;;;AAMA,aAAKC,GAAL,GAAWA,GAAX;;AAEA;;;;;;AAMA,aAAKE,QAAL,GAAgBA,QAAhB;;AAEA,YAAIJ,QAAJ,EAAc;AACV;AACAA,qBAASG,IAAT,GAAgB,KAAhB;AACAH,qBAASK,WAAT,CAAqBJ,KAArB;AACAD,qBAASM,aAAT,GAAyB,KAAKV,OAA9B;AACH;AACJ,K;;AAED;;;;;;;+BAKAW,O,sBAAU;AACN,aAAKP,QAAL,CAAcM,aAAd,GAA8B,IAA9B;AACA,aAAKP,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACAJ,yBAAiBa,KAAjB,CAAuBC,IAAvB,CAA4B,IAA5B;AACH,K;;AAED;;;;;;;;;+BAOAZ,M,mBAAOG,Q,EAAU;AACb,YAAIU,kBAAJ;AACA,YAAIV,SAASW,YAAT,IAAyB,KAAKT,GAAlC,EAAuC;;AAEnC;AACAF,qBAASW,YAAT,GAAwB,KAAKT,GAA7B;;AAEA,gBAAI,KAAKC,IAAT,EAAe;AACX;AACAH,yBAASY,eAAT;AACAZ,yBAASa,WAAT,CAAqB,KAAKZ,KAA1B;AACH,aAJD,MAIO;AACHD,yBAASc,IAAT;AACA,oBAAI,KAAKV,QAAT,EAAmB;AACfM,gCAAY,KAAKN,QAAjB;AACH;AACD,qBAAKU,IAAL,GALG,CAKU;AAChB;AACJ;AACD,eAAOJ,SAAP;AACH,K;;AAED;;;;;;+BAIAI,I,mBAAO;AACHC,aAAKC,OAAL,CAAaC,QAAb,CAAsBC,aAAtB,CAAoC,IAApC;AACH,K;;AAED;;;;;;;;AAsBA;;;;;;;;;;;qBAWOC,M,mBAAOnB,Q,EAAUC,K,EAAOC,G,EAAKC,I,EAAMC,Q,EAAU;AAChD,YAAIgB,QAAJ;AACA,YAAI,KAAKZ,KAAL,CAAWa,MAAf,EAAuB;AACnBD,uBAAW,KAAKZ,KAAL,CAAWc,GAAX,EAAX;AACH,SAFD,MAEO;AACHF,uBAAW,IAAIzB,gBAAJ,EAAX;AACH;AACDyB,iBAASrB,IAAT,CAAcC,QAAd,EAAwBC,KAAxB,EAA+BC,GAA/B,EAAoCC,IAApC,EAA0CC,QAA1C;AACA,eAAOgB,QAAP;AACH,K;;;;4BApCc;AACX,gBAAMG,WAAW,CAAC,KAAKvB,QAAL,CAAcW,YAAd,GAA6B,KAAKV,KAAnC,KAA6C,KAAKC,GAAL,GAAW,KAAKD,KAA7D,CAAjB;AACA,mBAAOuB,KAAKC,GAAL,CAAS,CAAT,EAAYD,KAAKE,GAAL,CAAS,CAAT,EAAYH,QAAZ,CAAZ,CAAP,CAFW,CAEgC;AAC9C;;AAED;;;;;;;;;;4BAOmB;AACf,mBAAO7B,IAAP;AACH;;;;;;AAyBLiC,OAAOC,OAAP,GAAiBjC,gBAAjB","file":"AnimatorTimeline.js","sourcesContent":["const pool = [];\r\n\r\n/**\r\n * Represents a single animation play.\r\n * @class AnimatorTimeline\r\n * @memberof PIXI.animate\r\n */\r\nclass AnimatorTimeline {\r\n    constructor() {\r\n        this._update = this.update.bind(this);\r\n        this.init(null, 0, 0, false, null);\r\n    }\r\n\r\n    /**\r\n     * The pool of timelines to use\r\n     * @method PIXI.animate.AnimatorTimeline#init\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @param {Number} start\r\n     * @param {Number} end\r\n     * @param {Boolean} loop\r\n     * @param {Function} callback\r\n     * @private\r\n     */\r\n    init(instance, start, end, loop, callback) {\r\n\r\n        /**\r\n         * Instance of clip to play.\r\n         * @name PIXI.animate.AnimatorTimeline#instance\r\n         * @type {PIXI.animate.MovieClip}\r\n         * @readOnly\r\n         */\r\n        this.instance = instance;\r\n\r\n        /**\r\n         * `true` if the timeline is suppose to loop.\r\n         * @name PIXI.animate.AnimatorTimeline#loop\r\n         * @type {Boolean}\r\n         * @readOnly\r\n         */\r\n        this.loop = loop;\r\n\r\n        /**\r\n         * Frame number of the starting farme.\r\n         * @name PIXI.animate.AnimatorTimeline#start\r\n         * @type {int}\r\n         * @readOnly\r\n         */\r\n        this.start = start;\r\n\r\n        /**\r\n         * Frame number of the ending frame.\r\n         * @name PIXI.animate.AnimatorTimeline#end\r\n         * @type {int}\r\n         * @readOnly\r\n         */\r\n        this.end = end;\r\n\r\n        /**\r\n         * Callback called when completed (non-looping animation).\r\n         * @name PIXI.animate.AnimatorTimeline#callback\r\n         * @type {Function}\r\n         * @readOnly\r\n         */\r\n        this.callback = callback;\r\n\r\n        if (instance) {\r\n            //Prevent overshooting the end frame and looping back around:\r\n            instance.loop = false;\r\n            instance.gotoAndStop(start);\r\n            instance._beforeUpdate = this._update;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Don't use after this\r\n     * @method PIXI.animate.AnimatorTimeline#destroy\r\n     * @private\r\n     */\r\n    destroy() {\r\n        this.instance._beforeUpdate = null;\r\n        this.init(null, 0, 0, false, null);\r\n        AnimatorTimeline._pool.push(this);\r\n    }\r\n\r\n    /**\r\n     * Is the animation complete\r\n     * @method PIXI.animate.AnimatorTimeline#update\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @return {Function} Callback to do after updateTimeline\r\n     * @private\r\n     */\r\n    update(instance) {\r\n        let completed;\r\n        if (instance.currentFrame >= this.end) {\r\n\r\n            // In case we over-shoot the current frame becuase of low FPS\r\n            instance.currentFrame = this.end;\r\n\r\n            if (this.loop) {\r\n                // Update timeline so we get actions at the end frame\r\n                instance._updateTimeline();\r\n                instance.gotoAndPlay(this.start);\r\n            } else {\r\n                instance.stop();\r\n                if (this.callback) {\r\n                    completed = this.callback;\r\n                }\r\n                this.stop(); // cleanup timeline\r\n            }\r\n        }\r\n        return completed;\r\n    }\r\n\r\n    /**\r\n     * Stop the animation, cannot be reused.\r\n     * @method PIXI.animate.AnimatorTimeline#stop\r\n     */\r\n    stop() {\r\n        PIXI.animate.Animator._internalStop(this);\r\n    }\r\n\r\n    /**\r\n     * The progress from 0 to 1 of the playback.\r\n     * @name PIXI.animate.AnimatorTimeline#progress\r\n     * @type {Number}\r\n     * @readOnly\r\n     */\r\n    get progress() {\r\n        const progress = (this.instance.currentFrame - this.start) / (this.end - this.start);\r\n        return Math.max(0, Math.min(1, progress)); // clamp\r\n    }\r\n\r\n    /**\r\n     * The pool of timelines to use\r\n     * @name PIXI.animate.AnimatorTimeline._pool\r\n     * @type {Array<PIXI.animate.AnimatorTimeline>}\r\n     * @static\r\n     * @private\r\n     */\r\n    static get _pool() {\r\n        return pool;\r\n    }\r\n\r\n    /**\r\n     * Create a new timeline\r\n     * @method PIXI.animate.AnimatorTimeline.create\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @param {Number} start\r\n     * @param {Number} end\r\n     * @param {Boolean} loop\r\n     * @param {Function} callback\r\n     * @return {PIXI.animate.AnimatorTimeline}\r\n     */\r\n    static create(instance, start, end, loop, callback) {\r\n        var timeline;\r\n        if (this._pool.length) {\r\n            timeline = this._pool.pop();\r\n        } else {\r\n            timeline = new AnimatorTimeline();\r\n        }\r\n        timeline.init(instance, start, end, loop, callback);\r\n        return timeline;\r\n    }\r\n}\r\n\r\nmodule.exports = AnimatorTimeline;"]}