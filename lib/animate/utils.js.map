{"version":3,"sources":["../../src/animate/utils.js"],"names":["_prepare","AnimateUtils","hexToUint","hex","substr","length","replace","parseInt","fillFrames","timeline","startFrame","duration","oldLength","fill","i","deserializeKeyframes","keyframes","result","keysMap","X","Y","A","B","C","D","R","L","T","F","V","c","buffer","isFrameStarted","prop","frame","parseValue","deserializeShapes","str","shapes","split","isCommand","shape","j","arg","test","parseFloat","push","forEach","val","upload","renderer","displayObject","done","plugins","prepare","register","addMovieClips","item","PIXI","animate","MovieClip","_timedChildTimelines","index","children","indexOf","target","add"],"mappings":"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","file":"utils.js","sourcesContent":["// If the movieclip plugin is installed\r\nlet _prepare = null;\r\n\r\n/**\r\n * @namespace PIXI.animate.utils\r\n * @description For keyframe conversions\r\n */\r\nexport default class AnimateUtils {\r\n\r\n    /**\r\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\r\n     * @static\r\n     * @method PIXI.animate.utils.hexToUint\r\n     */\r\n    static hexToUint(hex) {\r\n        // Remove the hash\r\n        hex = hex.substr(1);\r\n\r\n        // Convert shortcolors fc9 to ffcc99\r\n        if (hex.length === 3) {\r\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\r\n        }\r\n        return parseInt(hex, 16);\r\n    }\r\n\r\n    /** \r\n     * Fill frames with booleans of true (showing) and false (hidden).\r\n     * @static\r\n     * @method PIXI.animate.utils.fillFrames\r\n     * @param {Array<Boolean>} timeline\r\n     * @param {int} startFrame The start frame when the timeline shows up\r\n     * @param {int} duration The length of showing\r\n     */\r\n    static fillFrames(timeline, startFrame, duration) {\r\n        //ensure that the timeline is long enough\r\n        const oldLength = timeline.length;\r\n        if (oldLength < startFrame + duration) {\r\n            timeline.length = startFrame + duration;\r\n            //fill any gaps with false to denote that the child should be removed for a bit\r\n            if (oldLength < startFrame) {\r\n                //if the browser has implemented the ES6 fill() function, use that\r\n                if (timeline.fill) {\r\n                    timeline.fill(false, oldLength, startFrame);\r\n                } else {\r\n                    //if we can't use fill, then do a for loop to fill it\r\n                    for (let i = oldLength; i < startFrame; ++i) {\r\n                        timeline[i] = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //if the browser has implemented the ES6 fill() function, use that\r\n        if (timeline.fill) {\r\n            timeline.fill(true, startFrame, startFrame + duration);\r\n        } else {\r\n            const length = timeline.length;\r\n            //if we can't use fill, then do a for loop to fill it\r\n            for (let i = startFrame; i < length; ++i) {\r\n                timeline[i] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert serialized array into keyframes\r\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\r\n     * @static\r\n     * @method PIXI.animate.utils.deserializeKeyframes\r\n     * @param {String} keyframes\r\n     * @param {Object} Resulting keyframes\r\n     */\r\n    static deserializeKeyframes(keyframes) {\r\n        let result = {};\r\n        let i = 0;\r\n        let keysMap = {\r\n            X: 'x', // x position\r\n            Y: 'y', // y position\r\n            A: 'sx', // scale x\r\n            B: 'sy', // scale y\r\n            C: 'kx', // skew x\r\n            D: 'ky', // skew y\r\n            R: 'r', // rotation\r\n            L: 'a', // alpha\r\n            T: 't', // tint\r\n            F: 'c', // colorTransform\r\n            V: 'v' // visibility\r\n        };\r\n        let c,\r\n            buffer = '',\r\n            isFrameStarted = false,\r\n            prop,\r\n            frame = {};\r\n\r\n        while (i <= keyframes.length) {\r\n            c = keyframes[i];\r\n            if (keysMap[c]) {\r\n                if (!isFrameStarted) {\r\n                    isFrameStarted = true;\r\n                    result[buffer] = frame;\r\n                }\r\n                if (prop) {\r\n                    frame[prop] = this.parseValue(prop, buffer);\r\n                }\r\n                prop = keysMap[c];\r\n                buffer = '';\r\n                i++;\r\n            }\r\n            // Start a new prop\r\n            else if (!c || c === ' ') {\r\n                i++;\r\n                frame[prop] = this.parseValue(prop, buffer);\r\n                buffer = '';\r\n                prop = null;\r\n                frame = {};\r\n                isFrameStarted = false;\r\n            } else {\r\n                buffer += c;\r\n                i++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\r\n     * @static\r\n     * @method PIXI.animate.utils.deserializeShapes\r\n     * @param {String} str\r\n     * @param {Array} Resulting shapes map\r\n     */\r\n    static deserializeShapes(str) {\r\n        const result = [];\r\n        // each shape is a new line\r\n        let shapes = str.split(\"\\n\");\r\n        let isCommand = /^[a-z]{1,2}$/;\r\n        for (let i = 0; i < shapes.length; i++) {\r\n            let shape = shapes[i].split(' '); // arguments are space separated\r\n            for (let j = 0; j < shape.length; j++) {\r\n                // Convert all numbers to floats, ignore colors\r\n                let arg = shape[j];\r\n                if (arg[0] !== '#' && !isCommand.test(arg)) {\r\n                    shape[j] = parseFloat(arg);\r\n                }\r\n            }\r\n            result.push(shape);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /** \r\n     * Parse the value of the compressed keyframe.\r\n     * @method PIXI.animate.utils.parseValue\r\n     * @static\r\n     * @private\r\n     * @param {String} prop The property key\r\n     * @param {String} buffer The contents\r\n     * @return {*} The parsed value\r\n     */\r\n    static parseValue(prop, buffer) {\r\n        switch (prop) {\r\n            // Color transforms are parsed as an array\r\n            case 'c':\r\n                {\r\n                    buffer = buffer.split(',');\r\n                    buffer.forEach(function(val, i, buffer) {\r\n                        buffer[i] = parseFloat(val);\r\n                    });\r\n                    return buffer;\r\n                }\r\n                // Tint value should not be converted\r\n                // can be color uint or string\r\n            case 't':\r\n                {\r\n                    return buffer;\r\n                }\r\n                // The visiblity parse as boolean\r\n            case 'v':\r\n                {\r\n                    return !!parseInt(buffer);\r\n                }\r\n                // Everything else parse a floats\r\n            default:\r\n                {\r\n                    return parseFloat(buffer);\r\n                }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Upload all the textures and graphics to the GPU. \r\n     * @method PIXI.animate.utils.upload\r\n     * @static\r\n     * @param {PIXI.WebGLRenderer} renderer Render to upload to\r\n     * @param {PIXI.DisplayObject} clip MovieClip to upload\r\n     * @param {function} done When complete\r\n     */\r\n    static upload(renderer, displayObject, done) {\r\n        if (!_prepare) {\r\n            _prepare = renderer.plugins.prepare;\r\n            _prepare.register(this.addMovieClips);\r\n        }\r\n        _prepare.upload(displayObject, done);\r\n    }\r\n\r\n    /**\r\n     * Add movie clips to the upload prepare.\r\n     * @method PIXI.animate.utils.addMovieClips\r\n     * @static\r\n     * @private\r\n     * @param {*} item To add to the queue \r\n     */\r\n    static addMovieClips(item) {\r\n        if (item instanceof PIXI.animate.MovieClip) {\r\n            item._timedChildTimelines.forEach((timeline) => {\r\n                const index = item.children.indexOf(timeline.target);\r\n                if (index === -1) {\r\n                    _prepare.add(timeline.target);\r\n                }\r\n            });\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}"]}