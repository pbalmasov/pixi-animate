{"version":3,"sources":["../../src/animate/Animator.js"],"names":["timelines","Animator","play","instance","label","callback","loop","start","end","labelIsFunction","undefined","totalFrames","labelsMap","STOP_LABEL","LOOP_LABEL","Error","fromTo","to","currentFrame","startLabel","endLabel","stop","timeline","AnimatorTimeline","create","_timelines","push","gotoAndPlay","i","len","length","_internalStop","stopAll","splice","indexOf","destroy","module","exports"],"mappings":"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","file":"Animator.js","sourcesContent":["import AnimatorTimeline from './AnimatorTimeline';\r\n\r\n// Static collection of timelines\r\nconst timelines = [];\r\n\r\n/**\r\n * Play animation via start/stop frame labels\r\n * @class Animator\r\n * @memberof PIXI.animate\r\n */\r\nclass Animator {\r\n\r\n    /**\r\n     * The collection of timelines\r\n     * @name {Array<PIXI.animate.AnimatorTimeline>} PIXI.animate.Animator#_timelines\r\n     * @private\r\n     * @static\r\n     */\r\n    static get _timelines() {\r\n        return timelines;\r\n    }\r\n\r\n    /**\r\n     * Suffix added to label for a stop.\r\n     * @name {String} PIXI.animate.Animator.STOP_LABEL\r\n     * @static\r\n     * @default \"_stop\"\r\n     */\r\n    static get STOP_LABEL() {\r\n        return \"_stop\";\r\n    }\r\n\r\n    /**\r\n     * Suffix added to label for a loop.\r\n     * @name {String} PIXI.animate.Animator.LOOP_LABEL\r\n     * @static\r\n     * @default \"_loop\"\r\n     */\r\n    static get LOOP_LABEL() {\r\n        return \"_loop\";\r\n    }\r\n\r\n    /**\r\n     * Play an animation by frame labels. For instance, play animation sequence from\r\n     * \"idle\" to \"idle_stop\" or \"idle_loop\". If no event label is provided, will\r\n     * play the entire duration of the MovieClip.\r\n     * @method PIXI.animate.Animator#play\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     * @param {String|Function} [label] The frame label event to call, if no event is provided\r\n     *        will use the entire length of the MovieClip. Can also be the callback.\r\n     * @param {Function} [callback] Optional callback when complete\r\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\r\n     */\r\n    static play(instance, label, callback) {\r\n        let loop = false;\r\n        let start, end;\r\n        const labelIsFunction = typeof label === \"function\";\r\n        if (label === undefined || labelIsFunction) {\r\n            start = 0;\r\n            end = instance.totalFrames - 1;\r\n            if (labelIsFunction) {\r\n                callback = label;\r\n            }\r\n        } else {\r\n            start = instance.labelsMap[label];\r\n            end = instance.labelsMap[label + this.STOP_LABEL];\r\n            if (end === undefined) {\r\n                end = instance.labelsMap[label + this.LOOP_LABEL];\r\n                loop = true;\r\n            }\r\n            if (start === undefined) {\r\n                throw new Error(\"No start label matching '\" + label + \"'\");\r\n            } else if (end === undefined) {\r\n                throw new Error(\"No end label matching '\" + label + \"'\");\r\n            }\r\n        }\r\n        return this.fromTo(\r\n            instance,\r\n            start,\r\n            end,\r\n            loop,\r\n            callback\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Play an animation from the current frame to an end frame or label.\r\n     * @method PIXI.animate.Animator#to\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     * @param {String|Number} end The end frame or label.\r\n     * @param {Function} [callback] Optional callback when complete\r\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\r\n     */\r\n    static to(instance, end, callback) {\r\n        return this.fromTo(\r\n            instance,\r\n            instance.currentFrame,\r\n            end,\r\n            false,\r\n            callback\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Play a MovieClip from a start to end frame.\r\n     * @method PIXI.animate.Animator#fromTo\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     * @param {Number|String} start The starting frame index or label.\r\n     * @param {Number|String} end The ending frame index or label.\r\n     * @param {Boolean} [loop=false] If the animation should loop.\r\n     * @param {Function} [callback] Optional callback when complete\r\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\r\n     */\r\n    static fromTo(instance, start, end, loop, callback) {\r\n\r\n        if (typeof start === \"string\") {\r\n            const startLabel = start;\r\n            start = instance.labelsMap[startLabel];\r\n            if (start === undefined) {\r\n                throw new Error(\"No start label matching '\" + startLabel + \"'\");\r\n            }\r\n        }\r\n        if (typeof end === \"string\") {\r\n            const endLabel = end;\r\n            end = instance.labelsMap[endLabel];\r\n            if (end === undefined) {\r\n                throw new Error(\"No end label matching '\" + endLabel + \"'\");\r\n            }\r\n        }\r\n        if (start < 0) {\r\n            throw new Error('Start frame is out of bounds');\r\n        }\r\n        if (end >= instance.totalFrames) {\r\n            throw new Error('End frame is out of bounds');\r\n        }\r\n        if (start >= end) {\r\n            throw new Error('End frame is before start frame');\r\n        }\r\n\r\n        // Stop any animation that's playing\r\n        this.stop(instance);\r\n\r\n        loop = !!loop;\r\n\r\n        // Add a new timeline\r\n        const timeline = AnimatorTimeline.create(\r\n            instance,\r\n            start,\r\n            end,\r\n            loop,\r\n            callback\r\n        );\r\n        this._timelines.push(timeline);\r\n\r\n        // Set the current frame\r\n        if (instance.currentFrame !== start) {\r\n            instance.gotoAndPlay(start);\r\n        } else {\r\n            instance.play();\r\n        }\r\n        return timeline;\r\n    }\r\n\r\n    /**\r\n     * Stop the animation by instance.\r\n     * @method PIXI.animate.Animator#stop\r\n     * @static\r\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\r\n     */\r\n    static stop(instance) {\r\n        for (let i = 0, len = this._timelines.length; i < len; i++) {\r\n            const timeline = this._timelines[i];\r\n            if (timeline.instance === instance) {\r\n                this._internalStop(timeline);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all the currently playing animations.\r\n     * @method PIXI.animate.Animator#stopAll\r\n     * @static\r\n     */\r\n    static stopAll() {\r\n        for (let i = this._timelines.length - 1; i >= 0; i--) {\r\n            this._internalStop(this._timelines[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop the animation\r\n     * @method PIXI.animate.Animator#_internalStop\r\n     * @private\r\n     * @static\r\n     * @param {PIXI.animate.AnimatorTimeline} timeline Timeline to stop.\r\n     */\r\n    static _internalStop(timeline) {\r\n        this._timelines.splice(this._timelines.indexOf(timeline), 1);\r\n        timeline.instance.stop();\r\n        timeline.destroy();\r\n    }\r\n}\r\n\r\nmodule.exports = Animator;"]}