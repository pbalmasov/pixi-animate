{"version":3,"sources":["../../src/animate/MovieClip.js"],"names":["Container","PIXI","SharedTicker","Ticker","shared","MovieClip","options","duration","loop","framerate","labels","undefined","mode","INDEPENDENT","startPosition","Object","assign","currentFrame","_labels","_labelDict","name","label","position","push","sort","a","b","selfAdvance","paused","actionsEnabled","autoReset","_synchOffset","_prevPos","_t","_framerate","_duration","_totalFrames","_timelines","_timedChildTimelines","_depthSorted","_actions","_beforeUpdate","_tickListener","bind","_onAdded","_onRemoved","on","advance","_updateTimeline","_setTimelinePosition","_goto","parentFramerate","add","tickerDeltaTime","seconds","settings","TARGET_FPMS","remove","_autoExtend","endFrame","_parseProperties","properties","t","utils","hexToUint","v","_getChildTimeline","instance","i","length","target","timeline","Timeline","addTimedMask","keyframes","addKeyframe","m","parseInt","am","addTween","startFrame","ease","at","addTimedChild","SYNCHED","parentStartPosition","fillFrames","deserializeKeyframes","lastFrame","extendLastFrame","aa","callback","addAction","index","actions","ps","alias","playSound","animate","sound","emit","play","stop","gotoAndPlay","positionOrLabel","gotoAndStop","time","Math","floor","afterUpdateOnce","pos","NaN","_reset","synched","SINGLE_FRAME","doActions","startPos","isNaN","actionFrames","oldCurrentFrame","frame","j","tween","setPosition","timedChildTimelines","depthSorted","shouldBeChild","parent","addChild","removeChild","currentIndex","children","indexOf","addChildAt","child","frameActions","call","destroy","destroyChildren","hiddenChildren","timelines","_currentProps","current","len","value","o","fps","DEFAULT_FRAMERATE","extend","e","prototype","create","__parent","constructor"],"mappings":"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","file":"MovieClip.js","sourcesContent":["import Timeline from './Timeline';\r\nimport utils from './utils';\r\n\r\nconst Container = PIXI.Container;\r\nconst SharedTicker = PIXI.Ticker.shared;\r\n\r\n/**\r\n * Provide timeline playback of movieclip\r\n * @memberof PIXI.animate\r\n * @class MovieClip\r\n * @extends PIXI.Container\r\n * @constructor\r\n * @param {Object|int} [options] The options object or the mode to play\r\n * @param {int} [options.mode=0] The playback mode default is independent (0),\r\n * @param {int} [options.startPosition=0] The starting frame\r\n * @param {Boolean} [options.loop=true] If playback is looped\r\n * @param {Object} [options.labels] The frame labels map of label to frames\r\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\r\n * @param {int} [options.framerate=24] The framerate to use for independent mode\r\n */\r\nclass MovieClip extends Container {\r\n    constructor(options, duration, loop, framerate, labels) {\r\n        super();\r\n\r\n        // Default options\r\n        options = options === undefined ? {} : options;\r\n\r\n        // Options can also be the mode\r\n        if (typeof options === 'number') {\r\n            options = {\r\n                mode: options || MovieClip.INDEPENDENT,\r\n                duration: duration || 0,\r\n                loop: loop === undefined ? true : loop,\r\n                labels: labels || {},\r\n                framerate: framerate || 0,\r\n                startPosition: 0\r\n            };\r\n        } else {\r\n            // Apply defaults to options\r\n            options = Object.assign({\r\n                mode: MovieClip.INDEPENDENT,\r\n                startPosition: 0,\r\n                loop: true,\r\n                labels: {},\r\n                duration: 0,\r\n                framerate: 0\r\n            }, options);\r\n        }\r\n\r\n        /**\r\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\r\n         * See each constant for a description of the behaviour.\r\n         * @name PIXI.animate.MovieClip#mode\r\n         * @type int\r\n         * @default null\r\n         */\r\n        this.mode = options.mode;\r\n\r\n        /**\r\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\r\n         * @name PIXI.animate.MovieClip#startPosition\r\n         * @type Number\r\n         * @default 0\r\n         */\r\n        this.startPosition = options.startPosition;\r\n\r\n        /**\r\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\r\n         * @name PIXI.animate.MovieClip#loop\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.loop = !!options.loop;\r\n\r\n        /**\r\n         * The current frame of the movieclip.\r\n         * @name PIXI.animate.MovieClip#currentFrame\r\n         * @type Number\r\n         * @default 0\r\n         * @readOnly\r\n         */\r\n        this.currentFrame = 0;\r\n\r\n        /**\r\n         * The collection of private labels\r\n         * @name PIXI.animate.MovieClip#_labels\r\n         * @type Array\r\n         * @private\r\n         */\r\n        this._labels = [];\r\n\r\n        /**\r\n         * The collection of private labels\r\n         * @name PIXI.animate.MovieClip#_labelDict\r\n         * @type Object\r\n         * @private\r\n         */\r\n        this._labelDict = options.labels;\r\n        if (options.labels) {\r\n            for (let name in options.labels) {\r\n                let label = {\r\n                    label: name,\r\n                    position: options.labels[name]\r\n                };\r\n                this._labels.push(label);\r\n            }\r\n            this._labels.sort(function(a, b) {\r\n                return a.position - b.position;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * If true, this movieclip will animate automatically whenever it is on the stage.\r\n         * @name PIXI.animate.MovieClip#selfAdvance\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.selfAdvance = true;\r\n\r\n        /**\r\n         * If true, the MovieClip's position will not advance when ticked.\r\n         * @name PIXI.animate.MovieClip#paused\r\n         * @type Boolean\r\n         * @default false\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\r\n         * @name PIXI.animate.MovieClip#actionsEnabled\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.actionsEnabled = true;\r\n\r\n        /**\r\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\r\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\r\n         * <br><br>\r\n         * For example, if you had a character animation with a 'body' child MovieClip instance\r\n         * with different costumes on each frame, you could set body.autoReset = false, so that\r\n         * you can manually change the frame it is on, without worrying that it will be reset\r\n         * automatically.\r\n         * @name PIXI.animate.MovieClip#autoReset\r\n         * @type Boolean\r\n         * @default true\r\n         */\r\n        this.autoReset = true;\r\n\r\n        /**\r\n         * @name PIXI.animate.MovieClip#_synchOffset\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._synchOffset = 0;\r\n\r\n        /**\r\n         * @name PIXI.animate.MovieClip#_prevPos\r\n         * @type Number\r\n         * @default -1\r\n         * @private\r\n         */\r\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\r\n\r\n        /**\r\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\r\n         * elapsed from frame 0 in seconds.\r\n         * @name PIXI.animate.MovieClip#_t\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._t = 0;\r\n\r\n        /**\r\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\r\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\r\n         * framerate.\r\n         *\r\n         * @name PIXI.animate.MovieClip#_framerate\r\n         * @type {Number}\r\n         * @default 0\r\n         * @protected\r\n         */\r\n        this._framerate = options.framerate;\r\n\r\n        /**\r\n         * The total time in seconds for the animation. This is changed when setting the framerate.\r\n         * @name PIXI.animate.MovieClip#_duration\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._duration = 0;\r\n\r\n        /**\r\n         * The total duration in frames for the animation.\r\n         * @name PIXI.animate.MovieClip#_totalFrames\r\n         * @type Number\r\n         * @default 0\r\n         * @private\r\n         */\r\n        this._totalFrames = options.duration;\r\n\r\n        /**\r\n         * Standard tween timelines for all objects. Each element in the _timelines array\r\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\r\n         * @name PIXI.animate.MovieClip#_timelines\r\n         * @type Array\r\n         * @protected\r\n         */\r\n        this._timelines = [];\r\n\r\n        /**\r\n         * Array of child timelines denoting if a child is actively a child of this movieclip\r\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\r\n         * property, and is an array of boolean values indexed by frame.\r\n         * @name PIXI.animate.MovieClip#_timedChildTimelines\r\n         * @type {Array}\r\n         * @protected\r\n         */\r\n        this._timedChildTimelines = [];\r\n\r\n        /**\r\n         * Array to depth sort timed children\r\n         * @name PIXI.animate.MovieClip#_depthSorted\r\n         * @type {Array}\r\n         * @private\r\n         */\r\n        this._depthSorted = [];\r\n\r\n        /**\r\n         * Array of frame scripts, indexed by frame.\r\n         * @name PIXI.animate.MovieClip#_actions\r\n         * @type {Array}\r\n         * @protected\r\n         */\r\n        this._actions = [];\r\n\r\n        /**\r\n         * Optional callback fired before timeline is updated.\r\n         * Can be used to clamp or update the currentFrame.\r\n         * @name PIXI.animate.MovieClip#_beforeUpdate\r\n         * @type {Function}\r\n         * @private\r\n         */\r\n        this._beforeUpdate = null;\r\n\r\n        if (this.mode === MovieClip.INDEPENDENT) {\r\n            this._tickListener = this._tickListener.bind(this);\r\n            this._onAdded = this._onAdded.bind(this);\r\n            this._onRemoved = this._onRemoved.bind(this);\r\n            this.on('added', this._onAdded);\r\n            this.on('removed', this._onRemoved);\r\n        }\r\n\r\n        if (options.framerate) {\r\n            this.framerate = options.framerate;\r\n        }\r\n\r\n        //save often used methods on the instance so that they can be fetched slightly faster\r\n        //than if they had to be fetched from the prototype\r\n        this.advance = this.advance;\r\n        this._updateTimeline = this._updateTimeline;\r\n        this._setTimelinePosition = this._setTimelinePosition;\r\n        this._goto = this._goto;\r\n    }\r\n\r\n    _onAdded() {\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n        SharedTicker.add(this._tickListener);\r\n    }\r\n\r\n    _tickListener(tickerDeltaTime) {\r\n        if (this.paused || !this.selfAdvance) {\r\n            //see if the movieclip needs to be updated even though it isn't animating\r\n            if (this._prevPos < 0) {\r\n                this._goto(this.currentFrame);\r\n            }\r\n            return;\r\n        }\r\n        let seconds = tickerDeltaTime / PIXI.settings.TARGET_FPMS / 1000;\r\n        this.advance(seconds);\r\n    }\r\n\r\n    _onRemoved() {\r\n        SharedTicker.remove(this._tickListener);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\r\n     * @name PIXI.animate.MovieClip#labels\r\n     * @type {Array}\r\n     * @readonly\r\n     */\r\n    get labels() {\r\n        return this._labels;\r\n    }\r\n\r\n    /**\r\n     * Returns a dictionary of labels where key is the label and value is the frame.\r\n     * @name PIXI.animate.MovieClip#labelsMap\r\n     * @type {Object}\r\n     * @readonly\r\n     */\r\n    get labelsMap() {\r\n        return this._labelDict;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the label on or immediately before the current frame.\r\n     * @name PIXI.animate.MovieClip#currentLabel\r\n     * @type {String}\r\n     * @readonly\r\n     */\r\n    get currentLabel() {\r\n        let labels = this._labels;\r\n        let current = null;\r\n        for (let i = 0, len = labels.length; i < len; ++i) {\r\n            if (labels[i].position <= this.currentFrame) {\r\n                current = labels[i].label;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\r\n     * @name PIXI.animate.MovieClip#elapsedTime\r\n     * @type Number\r\n     * @default 0\r\n     * @public\r\n     */\r\n    get elapsedTime() {\r\n        return this._t;\r\n    }\r\n\r\n    set elapsedTime(value) {\r\n        this._t = value;\r\n    }\r\n\r\n    /**\r\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\r\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\r\n     * framerate.\r\n     *\r\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\r\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\r\n     * vary slightly between frames.\r\n     *\r\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\r\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\r\n     * @name PIXI.animate.MovieClip#framerate\r\n     * @type {Number}\r\n     * @default 0\r\n     */\r\n    get framerate() {\r\n        return this._framerate;\r\n    }\r\n    set framerate(value) {\r\n        if (value > 0) {\r\n            if (this._framerate) {\r\n                //recalculate time based on difference between new and old framerate:\r\n                this._t *= this._framerate / value;\r\n            } else {\r\n                this._t = this.currentFrame / value;\r\n            }\r\n            this._framerate = value;\r\n            this._duration = value ? this._totalFrames / value : 0;\r\n        } else {\r\n            this._t = this._framerate = this._duration = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the total number of frames (duration) of this MovieClip\r\n     * @name PIXI.animate.MovieClip#totalFrames\r\n     * @type {Number}\r\n     * @default 0\r\n     * @readOnly\r\n     */\r\n    get totalFrames() {\r\n        return this._totalFrames;\r\n    }\r\n\r\n    /**\r\n     * Extend the timeline to the last frame.\r\n     * @method PIXI.animate.MovieClip#_autoExtend\r\n     * @private\r\n     * @param {int} endFrame\r\n     */\r\n    _autoExtend(endFrame) {\r\n        if (this._totalFrames < endFrame) {\r\n            this._totalFrames = endFrame;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert values of properties\r\n     * @method PIXI.animate.MovieClip#_parseProperties\r\n     * @private\r\n     * @param {Object} properties\r\n     */\r\n    _parseProperties(properties) {\r\n        // Convert any string colors to uints\r\n        if (typeof properties.t === 'string') {\r\n            properties.t = utils.hexToUint(properties.t);\r\n        } else if (typeof properties.v === 'number') {\r\n            properties.v = !!properties.v;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a timeline for a child, synced timeline.\r\n     * @method PIXI.animate.MovieClip#_getChildTimeline\r\n     * @private\r\n     * @param {PIXI.animate.MovieClip} instance\r\n     * @return {PIXI.animate.Timeline}\r\n     */\r\n    _getChildTimeline(instance) {\r\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\r\n            if (this._timelines[i].target === instance) {\r\n                return this._timelines[i];\r\n            }\r\n        }\r\n        let timeline = new Timeline(instance);\r\n        this._timelines.push(timeline);\r\n        return timeline;\r\n    }\r\n\r\n    /**\r\n     * Add mask or masks\r\n     * @method PIXI.animate.MovieClip#addTimedMask\r\n     * @param {PIXI.DisplayObject} instance Instance to mask\r\n     * @param {Object} keyframes The map of frames to mask objects\r\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\r\n     */\r\n    addTimedMask(instance, keyframes) {\r\n        for (let i in keyframes) {\r\n            this.addKeyframe(instance, {\r\n                m: keyframes[i]\r\n            }, parseInt(i, 10));\r\n        }\r\n\r\n        // Set the initial position/add\r\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Shortcut alias for `addTimedMask`\r\n     * @method PIXI.animate.MovieClip#am\r\n     * @param {PIXI.DisplayObject} instance Instance to mask\r\n     * @param {Object} keyframes The map of frames to mask objects\r\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\r\n     */\r\n    am(instance, keyframes) {\r\n        return this.addTimedMask(instance, keyframes);\r\n    }\r\n\r\n    /**\r\n     * Add a tween to the clip\r\n     * @method PIXI.animate.MovieClip#addTween\r\n     * @param {PIXI.DisplayObject} instance The clip to tween\r\n     * @param {Object} properties The property or property to tween\r\n     * @param {int} startFrame The frame to start tweening\r\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\r\n     *                           with no tweening.\r\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addTween(instance, properties, startFrame, duration, ease) {\r\n\r\n        let timeline = this._getChildTimeline(instance);\r\n        this._parseProperties(properties);\r\n        timeline.addTween(properties, startFrame, duration, ease);\r\n        this._autoExtend(startFrame + duration);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a tween to the clip\r\n     * @method PIXI.animate.MovieClip#addKeyframe\r\n     * @param {PIXI.DisplayObject} instance The clip to tween\r\n     * @param {Object} properties The property or property to tween\r\n     * @param {int} startFrame The frame to start tweening\r\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\r\n     *                           with no tweening.\r\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addKeyframe(instance, properties, startFrame) {\r\n\r\n        let timeline = this._getChildTimeline(instance);\r\n        this._parseProperties(properties);\r\n        timeline.addKeyframe(properties, startFrame);\r\n        this._autoExtend(startFrame);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Alias for method `addTimedChild`\r\n     * @method PIXI.animate.MovieClip#at\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    at(instance, startFrame, duration, keyframes) {\r\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\r\n    }\r\n\r\n    /**\r\n     * Add a child to show for a certain number of frames before automatic removal.\r\n     * @method PIXI.animate.MovieClip#addTimedChild\r\n     * @param {PIXI.DisplayObject} instance The clip to show\r\n     * @param {int} startFrame The starting frame\r\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\r\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addTimedChild(instance, startFrame, duration, keyframes) {\r\n\r\n        if (startFrame === undefined) // jshint ignore:line\r\n        {\r\n            startFrame = 0;\r\n        }\r\n        if (duration === undefined || duration < 1) // jshint ignore:line\r\n        {\r\n            duration = this._totalFrames || 1;\r\n        }\r\n\r\n        // Add the starting offset for synced movie clips\r\n        if (instance.mode === MovieClip.SYNCHED) {\r\n            instance.parentStartPosition = startFrame;\r\n        }\r\n\r\n        //add tweening info about this child's presence on stage\r\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\r\n        //should be set back to frame 0\r\n        let timeline, i;\r\n        //get existing timeline\r\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\r\n            if (this._timedChildTimelines[i].target === instance) {\r\n                timeline = this._timedChildTimelines[i];\r\n                break;\r\n            }\r\n        }\r\n        //if there wasn't one, make a new one\r\n        if (!timeline) {\r\n            timeline = [];\r\n            timeline.target = instance;\r\n            this._timedChildTimelines.push(timeline);\r\n        }\r\n\r\n        // Fill the timeline with keyframe booleans\r\n        utils.fillFrames(timeline, startFrame, duration);\r\n\r\n        // Update the total frames if the instance extends our current\r\n        // total frames for this movieclip\r\n        if (this._totalFrames < startFrame + duration) {\r\n            this._totalFrames = startFrame + duration;\r\n        }\r\n\r\n        // Add the collection of keyframes\r\n        if (keyframes) {\r\n            if (typeof keyframes === \"string\") {\r\n                keyframes = utils.deserializeKeyframes(keyframes);\r\n            }\r\n            // Convert the keyframes object into\r\n            // individual properties\r\n            let lastFrame = {};\r\n            for (let i in keyframes) {\r\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\r\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\r\n            }\r\n            this._getChildTimeline(instance)\r\n                .extendLastFrame(startFrame + duration);\r\n        }\r\n\r\n        // Set the initial position/add\r\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Short cut for `addAction`\r\n     * @method PIXI.animate.MovieClip#aa\r\n     * @param {Function} callback The clip call on a certain frame\r\n     * @param {int|String} startFrame The starting frame index or label\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    aa(callback, startFrame) {\r\n        return this.addAction(callback, startFrame);\r\n    }\r\n\r\n    /**\r\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\r\n     * @method PIXI.animate.MovieClip#addAction\r\n     * @param {Function} callback The clip call on a certain frame\r\n     * @param {int|String} startFrame The starting frame index or label\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    addAction(callback, startFrame) {\r\n\r\n        if (typeof startFrame === 'string') {\r\n            const index = this._labelDict[startFrame];\r\n            if (index === undefined) {\r\n                throw `The label '${startFrame}' does not exist on this timeline`;\r\n            }\r\n            startFrame = index;\r\n        }\r\n\r\n        let actions = this._actions;\r\n        //ensure that the movieclip timeline is long enough to support the target frame\r\n        if (actions.length <= startFrame) {\r\n            actions.length = startFrame + 1;\r\n        }\r\n        if (this._totalFrames < startFrame) {\r\n            this._totalFrames = startFrame;\r\n        }\r\n        //add the action\r\n        if (actions[startFrame]) {\r\n            actions[startFrame].push(callback);\r\n        } else {\r\n            actions[startFrame] = [callback];\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Short cut for `playSound`\r\n     * @method PIXI.animate.MovieClip#ps\r\n     * @param {String} alias The name of the Sound\r\n     * @param {Boolean} [loop=false] The loop property of the sound\r\n     * @param {MovieClip} context The MovieClip the sound originates from\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    ps(alias, loop) {\r\n        return this.playSound(alias, loop);\r\n    }\r\n\r\n    /**\r\n     * Handle sounds.\r\n     * @method PIXI.animate.MovieClip#playSound\r\n     * @param {String} alias The name of the Sound\r\n     * @param {Boolean} [loop=false] The loop property of the sound\r\n     * @param {MovieClip} context The MovieClip the sound originates from\r\n     * @return {PIXI.animate.MovieClip}\r\n     */\r\n    playSound(alias, loop) {\r\n        PIXI.animate.sound.emit('play', alias, !!loop, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets paused to false.\r\n     * @method PIXI.animate.MovieClip#play\r\n     */\r\n    play() {\r\n        this.paused = false;\r\n    }\r\n\r\n    /**\r\n     * Sets paused to true.\r\n     * @method PIXI.animate.MovieClip#stop\r\n     */\r\n    stop() {\r\n        this.paused = true;\r\n    }\r\n\r\n    /**\r\n     * Advances this movie clip to the specified position or label and sets paused to false.\r\n     * @method PIXI.animate.MovieClip#gotoAndPlay\r\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\r\n     */\r\n    gotoAndPlay(positionOrLabel) {\r\n        this.paused = false;\r\n        this._goto(positionOrLabel);\r\n    }\r\n\r\n    /**\r\n     * Advances this movie clip to the specified position or label and sets paused to true.\r\n     * @method PIXI.animate.MovieClip#gotoAndStop\r\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\r\n     */\r\n    gotoAndStop(positionOrLabel) {\r\n        this.paused = true;\r\n        this._goto(positionOrLabel);\r\n    }\r\n\r\n    /**\r\n     * Get the close parent with a valid framerate. If no parent, returns the default framerate.\r\n     * @name PIXI.animate.MovieClip#parentFramerate\r\n     * @type {Number}\r\n     * @readOnly\r\n     */\r\n    get parentFramerate() {\r\n        let o = this,\r\n            fps = o._framerate;\r\n        while ((o = o.parent) && !fps) {\r\n            if (o.mode === MovieClip.INDEPENDENT) {\r\n                fps = o._framerate;\r\n            }\r\n        }\r\n        return fps || MovieClip.DEFAULT_FRAMERATE;\r\n    }\r\n\r\n    /**\r\n     * Advances the playhead. This occurs automatically each tick by default.\r\n     * @method PIXI.animate.MovieClip#advance\r\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\r\n     */\r\n    advance(time) {\r\n\r\n        // Handle any other cases where starting to play\r\n        // and no framerate has been set yet\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n\r\n        if (time) {\r\n            this._t += time;\r\n        }\r\n        if (this._t > this._duration) {\r\n            this._t = this.loop ? this._t % this._duration : this._duration;\r\n        }\r\n        //add a tiny amount to account for potential floating point errors\r\n        this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\r\n        //final error checking\r\n        if (this.currentFrame >= this._totalFrames) {\r\n            this.currentFrame = this._totalFrames - 1;\r\n        }\r\n        let afterUpdateOnce;\r\n        if (this._beforeUpdate) {\r\n            afterUpdateOnce = this._beforeUpdate(this);\r\n        }\r\n        //update all tweens & actions in the timeline\r\n        this._updateTimeline();\r\n\r\n        // Do the animator callback here\r\n        if (afterUpdateOnce) {\r\n            afterUpdateOnce();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_goto\r\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\r\n     * @protected\r\n     */\r\n    _goto(positionOrLabel) {\r\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\r\n        if (pos === undefined) // jshint ignore:line\r\n        {\r\n            return;\r\n        }\r\n        // prevent _updateTimeline from overwriting the new position because of a reset:\r\n        this._prevPos = NaN;\r\n        this.currentFrame = pos;\r\n\r\n        // Handle the case where trying to play but haven't\r\n        // added to the stage yet\r\n        if (!this._framerate) {\r\n            this.framerate = this.parentFramerate;\r\n        }\r\n\r\n        //update the elapsed time if a time based movieclip\r\n        if (this._framerate > 0) {\r\n            this._t = pos / this._framerate;\r\n        } else {\r\n            this._t = 0;\r\n        }\r\n        this._updateTimeline();\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_reset\r\n     * @private\r\n     */\r\n    _reset() {\r\n        this._prevPos = -1;\r\n        this._t = 0;\r\n        this.currentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * @method PIXI.animate.MovieClip#_updateTimeline\r\n     * @protected\r\n     */\r\n    _updateTimeline() {\r\n        let synched = this.mode !== MovieClip.INDEPENDENT;\r\n\r\n        if (synched) {\r\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\r\n            if (this.currentFrame >= this._totalFrames) {\r\n                this.currentFrame %= this._totalFrames;\r\n            }\r\n        }\r\n\r\n        if (this._prevPos === this.currentFrame) {\r\n            return;\r\n        }\r\n\r\n        // update timeline position, ignoring actions if this is a graphic.\r\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\r\n\r\n        this._prevPos = this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Set the timeline position\r\n     * @method PIXI.animate.MovieClip#_setTimelinePosition\r\n     * @protected\r\n     * @param {int} startFrame\r\n     * @param {int} currentFrame\r\n     * @param {Boolean} doActions\r\n     */\r\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\r\n        if (startFrame !== currentFrame && doActions) {\r\n            let startPos = isNaN(startFrame) ? currentFrame : (startFrame >= this._totalFrames - 1 ? 0 : startFrame + 1);\r\n            // generate actionFrames on the way\r\n            let actionFrames = [];   // number[]\r\n            // loop\r\n            if (currentFrame < startPos) {\r\n                for (let i = startPos; i < this._actions.length; ++i) {\r\n                    this._actions[i] && actionFrames.push(i);\r\n                }\r\n                for (let i = 0; i <= currentFrame; ++i) {\r\n                    this._actions[i] && actionFrames.push(i);\r\n                }\r\n            }\r\n            // no loop\r\n            else {\r\n                for (let i = startPos; i <= currentFrame; ++i) {\r\n                    this._actions[i] && actionFrames.push(i);\r\n                }\r\n            }\r\n\r\n            if (actionFrames.length) {\r\n                let oldCurrentFrame = this.currentFrame;\r\n                for (let i = 0; i < actionFrames.length; ++i) {\r\n                    let frame = actionFrames[i];\r\n                    this._setTimelinePosition(frame, frame, true);\r\n                    // _goto is called OR last frame reached\r\n                    if (this.currentFrame !== oldCurrentFrame || frame === currentFrame) {\r\n                        return;\r\n                    }\r\n                    // stop is called\r\n                    else if (this.paused) {\r\n                        this.currentFrame = frame;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //handle all tweens\r\n        let i, j, length, _timelines = this._timelines;\r\n        for (i = _timelines.length - 1; i >= 0; --i) {\r\n            let timeline = _timelines[i];\r\n            for (j = 0, length = timeline.length; j < length; ++j) {\r\n                let tween = timeline[j];\r\n                //if the tween contains part of the timeline that we are travelling through\r\n                if (currentFrame >= tween.startFrame &&\r\n                    currentFrame <= tween.endFrame) {\r\n                    // set the position within that tween\r\n                    //and break the loop to move onto the next timeline\r\n                    tween.setPosition(currentFrame);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        let timedChildTimelines = this._timedChildTimelines;\r\n        let depthSorted = this._depthSorted;\r\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\r\n            let target = timedChildTimelines[i].target;\r\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\r\n            //if child should be on stage and is not:\r\n            if (shouldBeChild) {\r\n                // Add to the depthSorted object so we can\r\n                // check that items are property drawn later\r\n                depthSorted.push(target);\r\n                if (target.parent !== this) {\r\n                    // add the target if it's not there already\r\n                    this.addChild(target);\r\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\r\n                        target._reset();\r\n                    }\r\n                }\r\n            } else if (!shouldBeChild && target.parent === this) {\r\n                this.removeChild(target);\r\n            }\r\n        }\r\n\r\n        // Properly depth sort the children\r\n        for (i = 0, length = depthSorted.length; i < length; i++) {\r\n            let target = depthSorted[i];\r\n            let currentIndex = this.children.indexOf(target);\r\n            if (currentIndex !== i) {\r\n                this.addChildAt(target, i);\r\n            }\r\n        }\r\n\r\n        // Clear the temporary depth sorting array\r\n        depthSorted.length = 0;\r\n\r\n        //go through all children and update synched movieclips that are not single frames\r\n        let children = this.children,\r\n            child;\r\n        for (i = 0, length = children.length; i < length; ++i) {\r\n            child = children[i];\r\n            if (child.mode === MovieClip.SYNCHED) {\r\n                child._synchOffset = currentFrame - child.parentStartPosition;\r\n                child._updateTimeline();\r\n            }\r\n        }\r\n\r\n        //handle actions\r\n        if (doActions && this._actions && this._actions[currentFrame]) {\r\n            let frameActions = this._actions[currentFrame];\r\n            for (let j = 0; j < frameActions.length; ++j) {\r\n                frameActions[j].call(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    destroy(destroyChildren) {\r\n        if (this._tickListener) {\r\n            SharedTicker.remove(this._tickListener);\r\n            this._tickListener = null;\r\n        }\r\n        const hiddenChildren = [];\r\n        let timelines = this._timelines;\r\n        if (timelines) {\r\n            for (let i = 0; i < timelines.length; i++) {\r\n                const timeline = timelines[i];\r\n                hiddenChildren.push(timeline.target);\r\n                timeline._currentProps = null;\r\n                timeline.length = 0;\r\n            }\r\n        }\r\n        timelines = this._timedChildTimelines;\r\n        if (timelines) {\r\n            for (let i = 0; i < timelines.length; i++) {\r\n                const timeline = timelines[i];\r\n                if (hiddenChildren.indexOf(timeline.target) < 0) {\r\n                    hiddenChildren.push(timeline.target);\r\n                }\r\n                timeline._currentProps = null;\r\n                timeline.length = 0;\r\n            }\r\n        }\r\n        // Destroy all the children\r\n        for (let i = 0; i < hiddenChildren.length; i++) {\r\n            // Don't destroy children in the display list\r\n            if (this.children.indexOf(hiddenChildren[i]) < 0) {\r\n                hiddenChildren[i].destroy(destroyChildren);\r\n            }\r\n        }\r\n        hiddenChildren.length = 0;\r\n        this._actions = null;\r\n        this._timelines = null;\r\n        this._depthSorted = null;\r\n        this._timedChildTimelines = null;\r\n        this._beforeUpdate = null;\r\n        this._labels = null;\r\n        this._labelDict = null;\r\n        super.destroy(destroyChildren);\r\n    }\r\n}\r\n\r\n/**\r\n * The MovieClip will advance independently of its parent, even if its parent is paused.\r\n * This is the default mode.\r\n * @name PIXI.animate.MovieClip.INDEPENDENT\r\n * @static\r\n * @type String\r\n * @default 0\r\n * @readonly\r\n */\r\nMovieClip.INDEPENDENT = 0;\r\n\r\n/**\r\n * The MovieClip will only display a single frame (as determined by the startPosition property).\r\n * @name PIXI.animate.MovieClip.SINGLE_FRAME\r\n * @static\r\n * @type String\r\n * @default 1\r\n * @readonly\r\n */\r\nMovieClip.SINGLE_FRAME = 1;\r\n\r\n/**\r\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\r\n * the parent MovieClip.\r\n * @name PIXI.animate.MovieClip.SYNCHED\r\n * @static\r\n * @type String\r\n * @default 2\r\n * @readonly\r\n */\r\nMovieClip.SYNCHED = 2;\r\n\r\n\r\n/**\r\n * The default framerate if none is specified or there's not parent clip with a framerate.\r\n * @name PIXI.animate.MovieClip.DEFAULT_FRAMERATE\r\n * @static\r\n * @type Number\r\n * @default 24\r\n * @readonly\r\n */\r\nMovieClip.DEFAULT_FRAMERATE = 24;\r\n\r\n/**\r\n * Extend a container\r\n * @method PIXI.animate.MovieClip.extend\r\n * @static\r\n * @param {PIXI.animate.MovieClip} child The child function\r\n * @return {PIXI.animate.MovieClip} The child\r\n */\r\n/**\r\n * Extend a container (alias for `extend`)\r\n * @method PIXI.animate.MovieClip.e\r\n * @static\r\n * @param {PIXI.animate.MovieClip} child The child function\r\n * @return {PIXI.animate.MovieClip} The child\r\n */\r\nMovieClip.extend = MovieClip.e = function(child) {\r\n    child.prototype = Object.create(MovieClip.prototype);\r\n    child.prototype.__parent = MovieClip.prototype;\r\n    child.prototype.constructor = child;\r\n    return child;\r\n};\r\n\r\n// Assign to namespace\r\nexport default MovieClip;\r\n"]}